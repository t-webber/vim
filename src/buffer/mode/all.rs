use crossterm::event::{Event, KeyCode, KeyEvent, KeyModifiers};

use crate::buffer::keymaps::{Action, CombinablePending, GoToAction, OPending};
use crate::buffer::mode::insert::Insert;
use crate::buffer::mode::normal::Normal;
use crate::buffer::mode::traits::{Actions, HandleKeyPress};

/// Represents the vim mode of the buffer.
#[non_exhaustive]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Mode {
    /// Insert mode
    Insert,
    /// Normal mode
    #[default]
    Normal,
}

impl Mode {
    /// Handles opending event for [`CombinablePending`]
    const fn handle_combinable_opending_char_event(
        combinable_pending: CombinablePending,
        ch: char,
    ) -> (GoToAction, Option<GoToAction>) {
        match combinable_pending {
            CombinablePending::FindNext =>
                (GoToAction::NextOccurrenceOf(ch), None),
            CombinablePending::FindNextDecrement =>
                (GoToAction::NextOccurrenceOf(ch), Some(GoToAction::Left)),
            CombinablePending::FindPrevious =>
                (GoToAction::PreviousOccurrenceOf(ch), None),
            CombinablePending::FindPreviousIncrement =>
                (GoToAction::PreviousOccurrenceOf(ch), Some(GoToAction::Right)),
        }
    }

    /// Handle incoming terminal events on any kind.
    pub(crate) fn handle_event(
        self,
        event: &Event,
        pending: Option<OPending>,
    ) -> Actions {
        pending.map_or_else(
            || self.handle_non_opending_event(event),
            |old_pending| self.handle_opending_event(old_pending, event),
        )
    }

    /// Handles the terminal events when not in [`OPending`] mode
    fn handle_non_opending_event(self, event: &Event) -> Actions {
        event.as_key_press_event().map_or_else(
            Actions::default,
            |mut key_event| {
                fix_shift_modifier(&mut key_event);
                match key_event.modifiers {
                    KeyModifiers::NONE =>
                        self.handle_blank_key_press(key_event.code),
                    KeyModifiers::CONTROL =>
                        self.handle_ctrl_key_press(key_event.code),
                    KeyModifiers::SHIFT =>
                        self.handle_shift_key_press(key_event.code),
                    _ => Actions::default(),
                }
            },
        )
    }

    /// Handle a keypress when an [`OPending`] is in progress and waiting for
    /// keys.
    fn handle_opending_event(
        self,
        opending: OPending,
        event: &Event,
    ) -> Actions {
        if let Some(key_event) = event.as_key_press_event()
            && let KeyCode::Char(ch) = key_event.code
        {
            match opending {
                OPending::GoTo if ch == 'e' =>
                    GoToAction::EndOfPreviousWord.into(),
                OPending::GoTo if ch == 'E' =>
                    GoToAction::EndOfPreviousWORD.into(),
                OPending::GoTo => Actions::default(),
                OPending::CombinablePending(action) => {
                    let (first, maybe_second) =
                        Self::handle_combinable_opending_char_event(action, ch);
                    maybe_second.map_or_else(
                        || first.into(),
                        |second| vec![first.into(), second.into()].into(),
                    )
                }
                OPending::ReplaceOne => Action::ReplaceWith(ch).into(),
                OPending::DeleteAction(action) => {
                    let (first, second) =
                        Self::handle_operator_action(action, ch);
                    Action::Delete(first, second).into()
                }
                OPending::ChangeAction(action) => {
                    let (first, second) =
                        Self::handle_operator_action(action, ch);
                    vec![Action::Delete(first, second), Self::Insert.into()]
                        .into()
                }
                OPending::Change => self.handle_operator(
                    event,
                    OPending::Change,
                    vec![Action::DeleteLine, Self::Insert.into()].into(),
                    OPending::ChangeAction,
                    |goto_action| {
                        vec![
                            Action::Delete(goto_action, None),
                            Self::Insert.into(),
                        ]
                        .into()
                    },
                ),
                OPending::Delete => self.handle_operator(
                    event,
                    OPending::Delete,
                    Action::DeleteLine.into(),
                    OPending::DeleteAction,
                    |goto_action| Action::Delete(goto_action, None).into(),
                ),
            }
        } else {
            Actions::default()
        }
    }

    /// Handle operator events (`d`, `c`, etc.)
    fn handle_operator(
        self,
        event: &Event,
        opending: OPending,
        actions: Actions,
        make_opending: impl Fn(CombinablePending) -> OPending,
        make_action: impl Fn(GoToAction) -> Actions,
    ) -> Actions {
        match self.handle_non_opending_event(event) {
            Actions::List(list) => {
                if let &[list_action] = list.as_slice()
                    && let Action::GoTo(goto_action) = list_action
                {
                    make_action(goto_action)
                } else {
                    list.into()
                }
            }
            Actions::OPending(OPending::CombinablePending(combinable)) =>
                make_opending(combinable).into(),
            Actions::OPending(pending) if pending == opending => actions,
            Actions::OPending(_) => Actions::default(),
        }
    }

    /// Handle operator action events (`dw`, `cw`, etc.)
    const fn handle_operator_action(
        action: CombinablePending,
        ch: char,
    ) -> (GoToAction, Option<GoToAction>) {
        let (first, maybe_second) =
            Self::handle_combinable_opending_char_event(action, ch);
        let second = match action {
            CombinablePending::FindNext => Some(GoToAction::Right),
            CombinablePending::FindNextDecrement => None,
            CombinablePending::FindPrevious
            | CombinablePending::FindPreviousIncrement => maybe_second,
        };
        (first, second)
    }
}

impl HandleKeyPress for Mode {
    fn handle_blank_key_press(&self, code: KeyCode) -> Actions {
        #[expect(clippy::wildcard_enum_match_arm, reason = "take only a few")]
        match code {
            KeyCode::Left => return vec![GoToAction::Left.into()].into(),
            KeyCode::Right => return vec![GoToAction::Right.into()].into(),
            _ => (),
        }
        match *self {
            Self::Insert => Insert.handle_blank_key_press(code),
            Self::Normal => Normal.handle_blank_key_press(code),
        }
    }

    fn handle_ctrl_key_press(&self, code: KeyCode) -> Actions {
        match *self {
            Self::Insert => Insert.handle_ctrl_key_press(code),
            Self::Normal => Normal.handle_ctrl_key_press(code),
        }
    }

    fn handle_shift_key_press(&self, code: KeyCode) -> Actions {
        match *self {
            Self::Insert => Insert.handle_shift_key_press(code),
            Self::Normal => Normal.handle_shift_key_press(code),
        }
    }
}

/// Adds [`KeyModifiers::SHIFT`] if the event is a capital char, and capitalises
/// the char if the modifiers contain shift.
const fn fix_shift_modifier(key_event: &mut KeyEvent) {
    #[expect(clippy::else_if_without_else, reason = "checked")]
    if let KeyCode::Char(ch) = &mut key_event.code {
        if ch.is_ascii_uppercase() {
            key_event.modifiers =
                key_event.modifiers.union(KeyModifiers::SHIFT);
        } else if key_event.modifiers.contains(KeyModifiers::SHIFT) {
            *ch = ch.to_ascii_uppercase();
        }
    }
}
