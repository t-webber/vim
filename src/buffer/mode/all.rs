use crossterm::event::{Event, KeyCode, KeyEvent, KeyModifiers};

use crate::buffer::keymaps::{Action, CombinablePending, GoToAction, OPending};
use crate::buffer::mode::insert::Insert;
use crate::buffer::mode::normal::Normal;
use crate::buffer::mode::traits::{Actions, HandleKeyPress};

/// Represents the vim mode of the buffer.
#[non_exhaustive]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Mode {
    /// Insert mode
    Insert,
    /// Normal mode
    #[default]
    Normal,
}

impl Mode {
    /// Handles opending event for [`CombinablePending`]
    const fn handle_combinable_opending_char_event(
        combinable_pending: CombinablePending,
        ch: char,
    ) -> (GoToAction, Option<GoToAction>) {
        match combinable_pending {
            CombinablePending::FindNext =>
                (GoToAction::NextOccurrenceOf(ch), None),
            CombinablePending::FindNextDecrement =>
                (GoToAction::NextOccurrenceOf(ch), Some(GoToAction::Left)),
            CombinablePending::FindPrevious =>
                (GoToAction::PreviousOccurrenceOf(ch), None),
            CombinablePending::FindPreviousIncrement =>
                (GoToAction::PreviousOccurrenceOf(ch), Some(GoToAction::Right)),
        }
    }

    /// Handle incoming terminal events on any kind.
    pub(crate) fn handle_event(
        self,
        event: &Event,
        pending: Option<OPending>,
    ) -> Actions {
        pending.map_or_else(
            || self.handle_non_opending_event(event),
            |old_pending| self.handle_opending_event(old_pending, event),
        )
    }

    /// Handles the terminal events when not in [`OPending`] mode
    fn handle_non_opending_event(self, event: &Event) -> Actions {
        event.as_key_press_event().map_or_else(
            Actions::default,
            |mut key_event| {
                fix_shift_modifier(&mut key_event);
                match key_event.modifiers {
                    KeyModifiers::NONE =>
                        self.handle_blank_key_press(key_event.code),
                    KeyModifiers::CONTROL =>
                        self.handle_ctrl_key_press(key_event.code),
                    KeyModifiers::SHIFT =>
                        self.handle_shift_key_press(key_event.code),
                    _ => Actions::default(),
                }
            },
        )
    }

    /// Handle a keypress when an [`OPending`] is in progress and waiting for
    /// keys.
    fn handle_opending_event(
        self,
        opending: OPending,
        event: &Event,
    ) -> Actions {
        if let Some(key_event) = event.as_key_press_event()
            && let KeyCode::Char(ch) = key_event.code
        {
            match opending {
                OPending::CombinablePending(action) => {
                    let (first, maybe_second) =
                        Self::handle_combinable_opending_char_event(action, ch);
                    maybe_second.map_or_else(
                        || first.into(),
                        |second| vec![first.into(), second.into()].into(),
                    )
                }
                OPending::ReplaceOne => Action::ReplaceWith(ch).into(),
                OPending::Delete => match self.handle_non_opending_event(event)
                {
                    Actions::List(list) => {
                        if let &[action] = list.as_slice()
                            && let Action::GoTo(goto_action) = action
                        {
                            Action::Delete(goto_action, None).into()
                        } else {
                            list.into()
                        }
                    }
                    Actions::OPending(OPending::CombinablePending(action)) =>
                        OPending::DeleteAction(action).into(),
                    Actions::OPending(OPending::Delete) =>
                        Action::DeleteLine.into(),
                    Actions::OPending(_) => Actions::default(),
                },
                OPending::DeleteAction(action) => {
                    let (first, maybe_second) =
                        Self::handle_combinable_opending_char_event(action, ch);
                    let second = match action {
                        CombinablePending::FindNext => Some(GoToAction::Right),
                        CombinablePending::FindNextDecrement => None,
                        CombinablePending::FindPrevious
                        | CombinablePending::FindPreviousIncrement =>
                            maybe_second,
                    };
                    Action::Delete(first, second).into()
                }
            }
        } else {
            Actions::default()
        }
    }
}

impl HandleKeyPress for Mode {
    fn handle_blank_key_press(&self, code: KeyCode) -> Actions {
        #[expect(clippy::wildcard_enum_match_arm, reason = "take only a few")]
        match code {
            KeyCode::Left => return vec![GoToAction::Left.into()].into(),
            KeyCode::Right => return vec![GoToAction::Right.into()].into(),
            _ => (),
        }
        match *self {
            Self::Insert => Insert.handle_blank_key_press(code),
            Self::Normal => Normal.handle_blank_key_press(code),
        }
    }

    fn handle_ctrl_key_press(&self, code: KeyCode) -> Actions {
        match *self {
            Self::Insert => Insert.handle_ctrl_key_press(code),
            Self::Normal => Normal.handle_ctrl_key_press(code),
        }
    }

    fn handle_shift_key_press(&self, code: KeyCode) -> Actions {
        match *self {
            Self::Insert => Insert.handle_shift_key_press(code),
            Self::Normal => Normal.handle_shift_key_press(code),
        }
    }
}

/// Adds [`KeyModifiers::SHIFT`] if the event is a capital char, and capitalises
/// the char if the modifiers contain shift.
const fn fix_shift_modifier(key_event: &mut KeyEvent) {
    #[expect(clippy::else_if_without_else, reason = "checked")]
    if let KeyCode::Char(ch) = &mut key_event.code {
        if ch.is_ascii_uppercase() {
            key_event.modifiers =
                key_event.modifiers.union(KeyModifiers::SHIFT);
        } else if key_event.modifiers.contains(KeyModifiers::SHIFT) {
            *ch = ch.to_ascii_uppercase();
        }
    }
}
